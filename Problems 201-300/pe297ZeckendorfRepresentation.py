##Each new term in the Fibonacci sequence is generated by adding the
##previous two terms.
##Starting with 1 and 2, the first 10 terms will be:
##1, 2, 3, 5, 8, 13, 21, 34, 55, 89.
##
##Every positive integer can be uniquely written as a sum of nonconsecutive
##terms of the Fibonacci sequence. For example, 100 = 3 + 8 + 89.
##Such a sum is called the Zeckendorf representation of the number.
##
##For any integer n>0, let z(n) be the number of terms in the Zeckendorf
##representation of n.
##Thus, z(5) = 1, z(14) = 2, z(100) = 3 etc.
##Also, for 0<n<10^6, ∑ z(n) = 7894453.
##
##Find ∑ z(n) for 0<n<10^17.

##########################################################################
## THEORY AND DESIGNER'S INTENT:                                        ##
##                                                                      ##
## Let F[n] be the nth term in the modified Fibonacci sequence          ##
## with F[0] = 1 and F[1] = 2. (Convenience of notation since that's    ##
## how arrays are stored in Python.)                                    ##
## It can be easily proved by induction that F[n]> ∑F[n-1-2i]           ##
## for all i>=0.                                                        ##
##                                                                      ##
## Consider a function T(n,k) producing the TOTAL number of sets of     ##
## k nonconsecutive terms, where all terms < F[n].                      ##
## T(0,k) = 1 when k>=0.                                                ##
## T(n,k) = 0 when n<2k, or when k<0.                                   ##
## T(n,k) = T(n-1,k) + T(n-2,k-1) otherwise: either F[k] is in          ##
## a particular set, or it is not.                                      ##
##                                                                      ##
## Now consider a set-counting function R(n,k,s) similar to T, but      ##
## with the RESTRICTION that the terms sum to s or less.                ##
## Return 0 if the sum of the first k nonconsecutive terms sum to       ##
## more than s, or if n<2k-1 or k<0.                                    ##
## Let F[g] be the maximum possible term in any valid set.              ##
## Then any set either contains F[g] - R(g-1,k-1,s-F[g]) options -      ##
## or it does not - T(g,k) options, because any nonconsecutive term     ##
## set with all terms less than F[g] will sum to less than F[g],        ##
## as per the lemma. Therefore                                          ##
## R(n,k,s) = R(g-1,k-1,s-F[g]) + T(g,k).                               ##
##                                                                      ##
## T can be computed ahead of time for all values of n and k, as the    ##
## Fibonacci sequence climbs above 10^17 pretty quickly.                ##
## R can be implemented with a standard recursive function.             ##
##                                                                      ##
## R(∞,k,10^17 - 1) is the number of nonconsecutive sets of k elements  ##
## which sum to less than 10^17.                                        ##
## Because the Zeckendorf representation is unique, each number less    ##
## than 10^17 will be the sum of one such set.                          ##
## Therefore ∑ z = ∑ k * R(∞,k,10^17 - 1).                              ##
##########################################################################

from time import time
import sys
sys.path.append("../Library")
from peresult import peresult

def solve(limit):
    start = time()
    F = [1, 2]
    while F[-1] + F[-2] < limit:
        F.append(F[-1] + F[-2])
    T = [ [1 for k in range(len(F)+1)] for n in range(len(F)+1)]
    T[0] = [1] + [0 for x in range(len(F) - 1)]
    T[1] = [1, 1] + [0 for x in range(len(F) - 1)]
    for n in range(2, len(F) + 1):
        for k in range(1, len(F) + 1):
            T[n][k] = T[n-1][k] + T[n-2][k-1]
    # tiny[k] is the sum of the first k nonconsecutive terms of F.
    # If tiny[k] > s, R(n,k,s) = 0.
    tiny = [0]
    for k in range(0, len(F), 2):
        tiny.append(tiny[-1] + F[k])
    def R(n,k,s):
        if n < 2 * k - 1 or k < 0 or tiny[k] > s:
            return 0
        if n == 0 or k == 0:
            return 1
        g = n - 1
        while F[g] + tiny[k-1] > s:
            g -= 1
        return R(g-1, k-1, s-F[g]) + T[g][k]
    result = 0
    for k in range(len(F)):
        result += k * R(len(F), k, limit - 1)
    peresult(297, result, time() - start)

if __name__ == "__main__":
    solve(10 ** 17)
